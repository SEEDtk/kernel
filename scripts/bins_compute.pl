#!/usr/bin/env perl
#
# Copyright (c) 2003-2015 University of Chicago and Fellowship
# for Interpretations of Genomes. All Rights Reserved.
#
# This file is part of the SEED Toolkit.
#
# The SEED Toolkit is free software. You can redistribute
# it and/or modify it under the terms of the SEED Toolkit
# Public License.
#
# You should have received a copy of the SEED Toolkit Public License
# along with this program; if not write to the University of Chicago
# at info@ci.uchicago.edu or the Fellowship for Interpretation of
# Genomes at veronika@thefig.info or download a copy from
# http://www.theseed.org/LICENSE.TXT.
#


use strict;
use warnings;
use FIG_Config;
use ScriptUtils;
use Bin::Compute;
use Bin::Score;
use Bin::Analyze;
use Stats;
use Time::HiRes qw(time);

=head1 Build Bins From Community Contigs

    bins_compute [ options ] workDirectory <contigFile

This script reads contig information from the standard input and partitions them into bins based
on criteria relating to closest reference genomes, universal roles, coverage, and tetranucleotides.
The contigs are represented by L<Bin> objects.

=head2 Parameters

The single positional parameter is the name of a working directory to contain temporary and output files.

The command-line options are those found in L<ScriptUtils/ih_options> and L<Bin::Score/script_options> plus the following

=over 4

=item parmfile

An output file from L<ga.pl> containing parameters to use for multiple runs. If this option is present, the
L<Bin::Score> options will be ignored.

=item id

If no C<parmfile> is specified, the ID to assign to this run. The default is C<1>.

=back

=head2 Input File

The input file contains one or more L<Bin> objects sequentially in the format described by L<Bin/Bin Exchange Format>.
Each represents a single contig from the input community.

=head3 Output Files

The output files are as follows, all in the working directory.

=over 4

=item bins.X.json

A file of L<Bin> objects in JSON format, suitable for reading by L<Bin/ReadBins>. These represent the computed bins.
The suffix I<X> is the ID number for the run. This will be C<1> for a single run, otherwise the ID from the input
file.

=item run.X.log

A log file from the run with ID I<X>.

=back

=cut

# Get the command-line parameters.
my $opt = ScriptUtils::Opts('workDirectory', ScriptUtils::ih_options(),
        Bin::Score::script_options(),
        ['parmfile=s', 'input parameter file for multiple runs'],
        ['id=i', 'run identifier', { default => 1 }]
        );
# Create the statistics object.
my $stats = Stats->new();
# This will be used for statistics generated by subprograms.
my $subStats;
# Open the input file.
my $ih = ScriptUtils::IH($opt->input);
# Get the list of contigs. These are read in as bins.
print "Reading contigs from input.\n";
my $binList = Bin::ReadContigs($ih);
# Verify the working directory.
my ($workDir) = @ARGV;
if (! $workDir) {
    die "No working directory specified.";
} elsif (! -d $workDir) {
    die "Invalid working directory $workDir.\n";
}
# Create the list of scoring objects.
my %runs;
if (! $opt->parmfile) {
    $runs{$opt->id} = Bin::Score->new_for_script($opt);
} else {
    open(my $ih, '<', $opt->parmfile) || die "Could not open parm file: $!";
    while (! eof $ih) {
        my $line = <$ih>;
        chomp $line;
        my (undef, $id, $covg, $tetra, $ref, $uniP, $uniW, $min) = split /\t/, $line;
        my $minscore = Bin::Score::scale_min($covg, $tetra, $ref, $uniW, $min);
        $runs{$id} = Bin::Score->new($covg, $tetra, $ref, $uniP, $uniW, $minscore);
    }
}
# Loop through the runs.
for my $runID (sort { $a <=> $b } keys %runs) {
    $stats->Add(runs => 1);
    print "Processing run $runID.\n";
    my $score = $runs{$runID};
    # Create the computation object.
    my $logFile = "$workDir/run.$runID.log";
    open(my $rh, '>', $logFile) || die "Could not open run log file: $!";
    my $computer = Bin::Compute->new($score, logFile => $rh);
    # Get a copy of the bin list.
    my @startBins = map { Bin->new_copy($_) } @$binList;
    # Compute the bins.
    my $start = time();
    my $bins = $computer->ProcessScores(\@startBins);
    my $duration = time() - $start;
    $stats->Accumulate($subStats);
    $stats->Add(duration => int($duration + 0.5));
    # Write the resulting bins.
    print "Writing bins.\n";
    open(my $oh, ">", "$workDir/bins.$runID.json") || die "Could not open bins output file: $!";
    for my $bin (@$bins) {
        $bin->Write($oh);
    }
    close $oh;
    # Analyze the bins.
    my $quality = Bin::Analyze::Quality($bins);
    print $rh "Quality score = $quality.\n";
    my $report = Bin::Analyze::Report($bins);
    print $rh "Quality Report\n" . $report->Show() . "\n";
    close $rh;
}
# Output the statistics.
print "All done.\n" . $stats->Show();
